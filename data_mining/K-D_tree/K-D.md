https://blog.csdn.net/v_july_v/article/details/8203674
http://blog.sina.cn/dpool/blog/s/blog_6f611c300101bysf.html
# K-D树
K-D树，即K-Dimensional Tree，是一种高维索引树型数据结构。常用于大规模高维数据空间的最邻近或者K邻近查找，例如图像检索中高维图像特征向量的K邻近匹配，对KNN算法的优化等。

## 1. K-D树的基本原理
K-D树实际上是一棵高维二叉搜索树，与普通二叉搜索树不同的是，树中存储的是一些K维数据。先回忆一下二叉搜索树（BST），它是一棵具有如下性质的树

    （1）若它的左子树不为空，那么左子树上所有节点的值均小于它的根节点的值。
    （2）若它的右子树不为空。那么右子树上所有节点的值均大于它的根节点的值。
    （3）它的左右子树也分别是一棵二叉搜索树。

 
   二叉搜索树在建树时，按照上述规则分别插入即可。而在搜索时，从根节点开始往下查找。可以看出二叉搜索树的建树平均时间复杂度为$O(nlog(n))$，最坏时间复杂度为$O(n^2)$，查找的平均时间复杂度为$O(log(n))$，最坏时间复杂度为$O(n)$，由于二叉搜索树不是平衡的，可能退化为一条链，这种情况就是最坏情况了。

   普通的二叉搜索树是一维的，当推广到K维后，就是我们的K-D树了。在K-D树中跟二叉搜索树差不多，也是将一个K维的数据与根节点进行比较，然后划分的，这里的比较不是整体的比较，而是选择其中一个维度来进行比较。那么在K-D树中我们需要解决两个重要的问题
    
    （1）每一次划分时，应该选择哪个维度？
    （2）在某个维度上划分时，如何保证左右子树节点个数尽量相等？

 - 首先来看问题（1）每次划分时，应该选择哪个维度 ？

   最简单的做法就是一个维度一个维度轮流着来，但是仔细想想，这种方法不能很好地解决问题。假设有这样一种情况：我们需要切一个豆腐条，长度要远远大于宽度，要想把它切成尽量相同的小块，显然是先按照长度来切，这样更合理，如果宽度比较窄，那么这种效果更明显。所以在K-D树中，每次选取属性跨度最大的那个来进行划分，而衡量这个跨度的标准是什么？ 无论是从数学上还是人的直观感受方面来说，如果某个属性的跨度越大，也就是说越分散，那么这组数据的方差就越大，所以在K-D树进行划分时，可以每次选择方差最大的属性来划分数据到左右子树。

- 现在再来看问题（2），在某个维度上划分时，如何保证左右子树节点个数尽量相等？


   当我们选择好划分的属性时，还要根据某个值来进行左右子树划分，而这个值就是一个划分轴，回忆一下，在快速排序算法中，也有一个划分轴pivot。在K-D树的划分中，这个轴的选取很关键，要保证划分后的左右子树尽量平衡，那么很显然选取这个属性的值对应数组的中位数作为pivot，就能保证这一点了。

 

这样就解决了K-D树中最重要的两个问题。接下来看K-D树是如何进行查找的。

 假设现在已经构造好了一棵K-D树，最邻近查找的算法描述如下

    （1）将查询数据Q从根节点开始，按照Q与各个节点的比较结果向下遍历，直到到达叶子节点为止。到达叶子节点时，计算Q与叶子节点上保存的所有数据之间的距离，记录最小距离对应的数据点，假设当前最邻近点为p_cur，最小距离记为d_cur。
    （2）进行回溯操作，该操作的目的是找离Q更近的数据点，即在未访问过的分支里，是否还有离Q更近的点，它们的距离小于d_cur。


## 2. K-D树的改进（BBF算法）

上述中的K-D树存在缺点，当维数比较大的时候，建树后的分支自然会增多，进而回溯的次数增加，算法效率会
   随之降低。在图像检索中，特征往往是高维的，很有必要对K-D树算法进行改进，这就是即将要介绍的BBF算法。
BBF算法我就不详细说了，具体可以参考如下两篇文章

## 3. K-D树的C++实现

http://acm.hdu.edu.cn/showproblem.php?pid=4347
**问题描述**

K 维空间中有很多点。给定一个点。找出最近的 m 个点。 欧几里得距离用作两点之间的距离度量。点p和q之间的欧几里得距离是连接它们的线段的长度。


**输入**

文本文件第一行有两个非负整数n和K，分别表示：

    点数，1 <= n <= 50000，

    维数，1 <= K <= 5 .

    在接下来的n行中，每一行都写有k个整数，代表一个点的坐标。 

    这之后是一行，其中包含一个正整数 t，代表查询的数量，1 <= t <=10000。

    每个查询包含两行。 第一行的 k 个整数代表给定的点。 在第二行，有一个整数 m。

    你应该找到的最近点的数量，1 <= m <=10。所有坐标的绝对值不会超过10000。
有多个测试用例。 处理到文件末尾。

**输出**

    对于每个查询，输出 m+1 行：
    第一行说：“最近的 m 个点是：”其中 m 是点的数量。
    下面m条线代表m个点，按照从近到远的顺序
    保证答案只能以一种方式形成。 给定点到所有最近的 m+1 个点的距离是不同的。 
    这意味着输入是这样的：
        2 2
        1 1
        3 3
        1
        2 2
        1
    将不存在。 

**code**

n_point.cpp

http://acm.hdu.edu.cn/showproblem.php?pid=2966

**问题描述**

为了帮助他们的客户处理有故障的自动取款机，The Planar Bank 的董事会决定贴上一个标签，表达银行对每台 ATM 故障的真诚遗憾和悲伤。 完全相同的标签会轻轻地要求客户冷静地前往最近的机器（希望应该
工作正常）。为此，已准备好所有 n 个 ATM 的二维位置列表，您的任务是为它们中的每一个找到与欧几里德距离最近的一个。
 
**输入**

输入包含几个测试用例。 第一行包含后面的案例数 t (t <= 15)。 每个测试用例都以自动取款机的数量 n (2 <= n <= 10^5) 开始。 接下来的 n 行中的每一行都包含一个取款机 x,y (0 <= x,y <=10^9) 的坐标，以空格分隔。 

没有两个一个测试用例中的点将重合。

**输出**

对于每个测试用例输出 n 行。 其中第 i 个应该包含第 i 个 ATM 与输入及其最近邻居之间的平方距离。

**code**

ATM.cpp

## 4. K-D树的开源框架介绍

https://github.com/sdeming/kdtree